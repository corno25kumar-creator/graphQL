                                                part - 1
GraphQL introduction ⭐
GraphQL vs REST ⭐
Problems GraphQL solves (over-fetching, under-fetching) ⭐
GraphQL architecture
Single endpoint concept ⭐
Schema ⭐
Schema Definition Language (SDL) ⭐
Scalar types ⭐
Object types ⭐
Custom types
Enums ⭐
Input types ⭐
Non-null types ⭐
Lists in GraphQL ⭐


                                                    part - 2
Query ⭐
Mutation ⭐
Subscription
Field selection ⭐
Arguments ⭐
Variables ⭐
Fragments
Aliases
Directives
Resolvers ⭐

                                                       part -  3
Resolver arguments (parent, args, context, info) ⭐
Nested resolvers ⭐
Context object ⭐
Authentication with JWT ⭐
Authorization (role-based, field-level) ⭐
Error handling in GraphQL ⭐
Custom error formatting ⭐
N+1 problem ⭐⭐ (VERY IMPORTANT)
DataLoader ⭐⭐ (VERY IMPORTANT)
Batching ⭐
Caching (client-side & server-side) ⭐
Apollo Server ⭐
Apollo Client ⭐   

                                                         part - 4
GraphiQL / Playground
Pagination (offset-based) ⭐
Pagination (cursor-based) ⭐
Connection pattern ⭐
Filtering
Sorting
Schema design best practices ⭐
Query complexity limiting ⭐
Depth limiting ⭐
Rate limiting ⭐
Performance optimization ⭐
Database optimization in resolvers ⭐
Monitoring and logging
Schema stitching
Apollo Federation
Subgraphs
Microservices with GraphQL
Subscriptions with WebSockets
Real-time updates
Testing GraphQL APIs ⭐
Unit testing resolvers ⭐
Integration testing ⭐
Security best practices ⭐
Introspection ⭐
Versioning strategies
Schema evolution ⭐
Breaking changes handling ⭐
Deployment strategies ⭐