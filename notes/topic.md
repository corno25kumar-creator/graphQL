                                             ✅ done <----  part - 1 -- > done ✅
GraphQL introduction ⭐  -- > done ✅
GraphQL vs REST ⭐   -- > done ✅
Problems GraphQL solves (over-fetching, under-fetching) ⭐  -- > done ✅

GraphQL architecture  -- > done ✅
Single endpoint concept ⭐-- > done ✅
Schema ⭐-- > done ✅

Schema Definition Language (SDL) ⭐ -- > done ✅
Scalar types ⭐ -- > done ✅
Custom types ⭐ -- > done ✅
Object types ⭐ -- > done ✅
Enums ⭐ -- > done ✅
Input types ⭐-- > done ✅
Non-null types ⭐ -- > done ✅
Lists in GraphQL ⭐ -- > done ✅


                                                    part - 2
Query ⭐
Mutation ⭐
Subscription
Field selection ⭐
Arguments ⭐
Variables ⭐
Fragments
Aliases
Directives
Resolvers ⭐

                                                       part -  3
Resolver arguments (parent, args, context, info) ⭐
Nested resolvers ⭐
Context object ⭐
Authentication with JWT ⭐
Authorization (role-based, field-level) ⭐
Error handling in GraphQL ⭐
Custom error formatting ⭐
N+1 problem ⭐⭐ (VERY IMPORTANT)
DataLoader ⭐⭐ (VERY IMPORTANT)
Batching ⭐
Caching (client-side & server-side) ⭐
Apollo Server ⭐
Apollo Client ⭐   

                                                         part - 4
GraphiQL / Playground
Pagination (offset-based) ⭐
Pagination (cursor-based) ⭐
Connection pattern ⭐
Filtering
Sorting
Schema design best practices ⭐
Query complexity limiting ⭐
Depth limiting ⭐
Rate limiting ⭐
Performance optimization ⭐
Database optimization in resolvers ⭐
Monitoring and logging
Schema stitching
Apollo Federation
Subgraphs
Microservices with GraphQL
Subscriptions with WebSockets
Real-time updates
Testing GraphQL APIs ⭐
Unit testing resolvers ⭐
Integration testing ⭐
Security best practices ⭐
Introspection ⭐
Versioning strategies
Schema evolution ⭐
Breaking changes handling ⭐
Deployment strategies ⭐